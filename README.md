# AMSL

Compile-time (constexpr) compiler for custom language

## Requirements

* GCC 13+

## Usage

* Modify the example code if you want `examples/minimal.amsl`:
```text
{
    let a: string = "Hello World!";
    let b: int;
    apply b = 10;
    let c: int = 20;
    @println("b = ", b, ", c = ", c, ", b + c ^ 2 = ", @add(b, @squared(c)));
    0
}
```
* Add CMake target: `add_amsl_target(minimal examples/minimal.amsl)`
* Build target
* Execute
* Check with godbolt, valgrind, or everything else if you don't believe

Run `minimal-introspection` to see detailed steps

## Step 1 - Embedder

Embed source code file into C++ source code

`examples/minimal.amsl.hpp` (automatically created before build and deleted after build, use `minimal-introspection` target to view):
```c++
#ifndef SOURCE_HPP
#define SOURCE_HPP

static constexpr const char source[] = "\x7b\x0d\x0a\x20\x20\x20\x20\x6c\x65\x74\x20\x61\x3a\x20\x73\x74\x72\x69\x6e\x67\x20\x3d\x20\x22\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x21\x22\x3b\x0d\x0a\x20\x20\x20\x20\x6c\x65\x74\x20\x62\x3a\x20\x69\x6e\x74\x3b\x0d\x0a\x20\x20\x20\x20\x61\x70\x70\x6c\x79\x20\x62\x20\x3d\x20\x31\x30\x3b\x0d\x0a\x20\x20\x20\x20\x6c\x65\x74\x20\x63\x3a\x20\x69\x6e\x74\x20\x3d\x20\x32\x30\x3b\x0d\x0a\x20\x20\x20\x20\x40\x70\x72\x69\x6e\x74\x6c\x6e\x28\x22\x62\x20\x3d\x20\x22\x2c\x20\x62\x2c\x20\x22\x2c\x20\x63\x20\x3d\x20\x22\x2c\x20\x63\x2c\x20\x22\x2c\x20\x62\x20\x2b\x20\x63\x20\x5e\x20\x32\x20\x3d\x20\x22\x2c\x20\x40\x61\x64\x64\x28\x62\x2c\x20\x40\x73\x71\x75\x61\x72\x65\x64\x28\x63\x29\x29\x29\x3b\x0d\x0a\x20\x20\x20\x20\x30\x0d\x0a\x7d";

#endif // SOURCE_HPP
```

## Step 2 - Lexer

Represents source code as a list of tokens
```text
Tokens: [string("{"), string("let"), string("a"), string(":"), string("string"), string("="), StringLiteral("Hello World!"), string(";"), string("let"), string("b"), string(":"), string("int"), string(";"), string("apply"), string("b"), string("="), IntLiteral(10), string(";"), string("let"), string("c"), string(":"), string("int"), string("="), IntLiteral(20), string(";"), string("@"), string("println"), string("("), StringLiteral("b = "), string(","), string("b"), string(","), StringLiteral(", c = "), string(","), string("c"), string(","), StringLiteral(", b + c ^ 2 = "), string(","), string("@"), string("add"), string("("), string("b"), string(","), string("@"), string("squared"), string("("), string("c"), string(")"), string(")"), string(")"), string(";"), IntLiteral(0), string("}")]
```

## Step 3 - Parser

Builds Abstract Syntax Tree (AST) from the tokens

```text
AST: ExpressionList(expressions=[VariableDeclarationWithInitializerExpression(name='a', type='string', initializer=LiteralExpression(value='Hello World!')), VariableDeclarationExpression(name='b', type='int'), AssignmentExpression(lhs=VariableExpression(name='b'), rhs=LiteralExpression(value=10)), VariableDeclarationWithInitializerExpression(name='c', type='int', initializer=LiteralExpression(value=20)), FunctionCallExpression(name='println', parameters=[LiteralExpression(value='b = '), VariableExpression(name='b'), LiteralExpression(value=', c = '), VariableExpression(name='c'), LiteralExpression(value=', b + c ^ 2 = '), FunctionCallExpression(name='add', parameters=[VariableExpression(name='b'), FunctionCallExpression(name='squared', parameters=[VariableExpression(name='c')])])]), LiteralExpression(value=0)])
```

## Step 4 - Analyzer

Refines (or optimizes) AST for the next steps

```text
Analyzed AST: AnalyzedExpressionList(expressions=[AnalyzedVariableDeclarationWithInitializerExpression(type='string', initializer=AnalyzedLiteralExpression(value='Hello World!')), AnalyzedVariableDeclarationExpression(type='int'), AnalyzedAssignmentExpression(lhs=AnalyzedVariableExpression(ref_id=0), rhs=AnalyzedLiteralExpression(value=10)), AnalyzedVariableDeclarationWithInitializerExpression(type='int', initializer=AnalyzedLiteralExpression(value=20)), AnalyzedFunctionCallExpression(name='println', parameters=[AnalyzedLiteralExpression(value='b = '), AnalyzedVariableExpression(ref_id=1), AnalyzedLiteralExpression(value=', c = '), AnalyzedVariableExpression(ref_id=0), AnalyzedLiteralExpression(value=', b + c ^ 2 = '), AnalyzedFunctionCallExpression(name='add', parameters=[AnalyzedVariableExpression(ref_id=1), AnalyzedFunctionCallExpression(name='squared', parameters=[AnalyzedVariableExpression(ref_id=0)])])]), AnalyzedLiteralExpression(value=0)])
```

## Step 5 - Encoder

Converts AST into a byte vector

```text
Byte vector: [0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x00, 0x08, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x21, 0x00, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x69, 0x6e, 0x74, 0x00, 0x06, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0a, 0x00, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x69, 0x6e, 0x74, 0x00, 0x07, 0x14, 0x00, 0x00, 0x00, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x6c, 0x6e, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x20, 0x3d, 0x20, 0x00, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x20, 0x63, 0x20, 0x3d, 0x20, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x20, 0x62, 0x20, 0x2b, 0x20, 0x63, 0x20, 0x5e, 0x20, 0x32, 0x20, 0x3d, 0x20, 0x00, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0x64, 0x64, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x71, 0x75, 0x61, 0x72, 0x65, 0x64, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00]
```

## Step 6 - Runtime to compile-time wall

Converts byte vector to constexpr-sized array

```text
Byte array: [0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x00, 0x08, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x21, 0x00, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x69, 0x6e, 0x74, 0x00, 0x06, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0a, 0x00, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x69, 0x6e, 0x74, 0x00, 0x07, 0x14, 0x00, 0x00, 0x00, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x6c, 0x6e, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x20, 0x3d, 0x20, 0x00, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x20, 0x63, 0x20, 0x3d, 0x20, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x20, 0x62, 0x20, 0x2b, 0x20, 0x63, 0x20, 0x5e, 0x20, 0x32, 0x20, 0x3d, 0x20, 0x00, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0x64, 0x64, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x71, 0x75, 0x61, 0x72, 0x65, 0x64, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00]
```

## Step 7 - Compiler

Compiles Type-based AST (TB-AST) from the byte array

```text
TB-AST: CompiledExpressionList<ParameterPack<CompiledVariableDeclarationWithInitializerExpression<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, CompiledLiteral<string_t<13>, string_t<13>{std::array<char, 13>{"Hello World!"}}> >, CompiledVariableDeclarationExpression<int>, CompiledAssignmentExpression<CompiledVariableExpression<0>, CompiledLiteral<int, 10> >, CompiledVariableDeclarationWithInitializerExpression<int, CompiledLiteral<int, 20> >, CompiledFunctionCallExpression<string_t<8>{std::array<char, 8>{"println"}}, ParameterPack<CompiledLiteral<string_t<5>, string_t<5>{std::array<char, 5>{"b = "}}>, CompiledVariableExpression<1>, CompiledLiteral<string_t<7>, string_t<7>{std::array<char, 7>{", c = "}}>, CompiledVariableExpression<0>, CompiledLiteral<string_t<15>, string_t<15>{std::array<char, 15>{", b + c ^ 2 = "}}>, CompiledFunctionCallExpression<string_t<4>{std::array<char, 4>{"add"}}, ParameterPack<CompiledVariableExpression<1>, CompiledFunctionCallExpression<string_t<8>{std::array<char, 8>{"squared"}}, ParameterPack<CompiledVariableExpression<0> > > > > > >, CompiledLiteral<int, 0> > >
```

## Step 8 - Executor

Does something as TB-AST instructs
